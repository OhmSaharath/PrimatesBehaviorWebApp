{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Web Application Platform for Behavioral Experiments In Non-human Primates This document is created for people who want to collaborate on the project, whether as researchers implementing tasks or engineers who want to further develop the web application and/or hardware integration. This project was conducted under the supervision of Dr. rer. nat. Lalitta Suriya-Arunroj at the Behavioral and Cognitive Neuroscience Lab, Chulalongkorn Hospital. Getting started Tour section provides a detailed explanation of the project. Tutorial section provides a step-by-step guide to implementing the web application's functions. If your role is a researcher , contributing to high-level functions like adding new tasks, it is suggested to first go through the Web application concept review to get familiar with thing under the hood of the system. If you still struggle with the concept, go through the Django concept review for an abstract overview of the core framework that powers the system. There is no need for a deep understanding of the framework, as the tutorial section will guide you with clear examples. If your role is an engineer , feel free to navigate through the Integrated System Implementation section for an explanation about the apparatus of this project.","title":"Home"},{"location":"#web-application-platform-for-behavioral-experiments-in-non-human-primates","text":"This document is created for people who want to collaborate on the project, whether as researchers implementing tasks or engineers who want to further develop the web application and/or hardware integration.","title":"Web Application Platform for Behavioral Experiments In Non-human Primates"},{"location":"#this-project-was-conducted-under-the-supervision-of-dr-rer-nat-lalitta-suriya-arunroj-at-the-behavioral-and-cognitive-neuroscience-lab-chulalongkorn-hospital","text":"","title":"This project was conducted under the supervision of Dr. rer. nat. Lalitta Suriya-Arunroj at the Behavioral and Cognitive Neuroscience Lab, Chulalongkorn Hospital."},{"location":"#getting-started","text":"Tour section provides a detailed explanation of the project. Tutorial section provides a step-by-step guide to implementing the web application's functions. If your role is a researcher , contributing to high-level functions like adding new tasks, it is suggested to first go through the Web application concept review to get familiar with thing under the hood of the system. If you still struggle with the concept, go through the Django concept review for an abstract overview of the core framework that powers the system. There is no need for a deep understanding of the framework, as the tutorial section will guide you with clear examples. If your role is an engineer , feel free to navigate through the Integrated System Implementation section for an explanation about the apparatus of this project.","title":"Getting started"},{"location":"tour/concept_explained/","text":"Django Quick Review","title":"Concept Explained"},{"location":"tour/concept_explained/#django-quick-review","text":"","title":"Django Quick Review"},{"location":"tour/integrated_system/","text":"Integrated System Implementation Apparatus (Prototype) A cage-based device is designed according to the marmoset experimental behavioral instrument (MXBI) [A.Calapai et al. 2022]. The device's design has been slightly modified from MXBI to enhance the capabilities of experiments. The main component is divided into three sections. Behavioral chamber Electronic compartment Waste bin Equipments The electronics compartment on the \u200bleft side of the instrument contains: Raspberry Pi 4 Model B Raspberry Pi Camera Module 3 2x Visaton FR58, 8 \u03a9, 120\u201320,000 Hz: Note that one speaker is housed in the electronics compartment, while the other is wired to the opposite side of the instrument. Peristaltic pump (JIHPUMP MN3 Mini OEM Peristaltic Pumps MN3/BT) 134.2K WL-134 Long distance RFID Animal Tag Reader Module 24v 7Ah Lithium ion battery with XT60 connector HW-652 YAMAHA YDA138-E 12W+12W Dual Channel Digital Audio Amplifier Board DC 12V TB6600 Single Axis 4A Stepper Motor Driver Controller 9~42V Micro-Step CNC 3x 300W 20A DC-DC Adjustable Step Down Converter Module Constant Current The behavioral chamber in the middle hosts: Waveshare 10.1inch Resistive Touch Screen LCD System Diagram The system utilizes a Raspberry Pi single-board computer to provide general-purpose input/output (GPIO) capabilities, enabling researchers to interface with a diverse range of external hardware components. The modular design allows for flexible hardware configurations tailored to specific task requirements. Touch Screen Connection A 10-inch Waveshare HDMI LCD touchscreen is employed for visual cognition tasks. To facilitate resistive touch functionality, only five pins are necessary for communication via the Serial Peripheral Interface (SPI) protocol. SCK (Serial Clock): Clock signal from the master (Raspberry Pi) to synchronize data transmission. MOSI (Master Out Slave In): Used for sending data from the master (Raspberry Pi) to the touchscreen controller. MISO (Master In Slave Out): Used for receiving data from the touchscreen controller to the master. CE1 (Chip Enable 1/Chip Select 1): Used to select the touchscreen for communication (low active). IRQ (Interrupt Request): Used by the touchscreen to signal the master that an event has occurred (low level while the Touch Panel detects touching). To preserve the remaining GPIO pins and ensure a modular design, the Raspberry Pi is not mounted directly onto the display module, as recommended in Waveshare\u2019s documentation. Instead of soldering the five pins directly from the back of the panel to connect to the Raspberry Pi, a detachable interface is utilized. Refer to the diagram below for the connection details. The panel requires screen configuration and touch calibration before it can be operational. Refer to the 'Software Setting' and 'Touch Calibration' sections in the Waveshare documentation for detailed instructions. Waveshare 10.1inch HDMI LCD Documentation Peristaltic Pumps Connection The Mini OEM Peristaltic Pump, model MN3/BT from JIHPump, is powered by a 24V DC, 48W stepper motor. To unlock its full potential, the system utilizes a TB6600 controller, enabling precise control and synchronization. The MN3/BT employs a 4-wire stepper motor, comprising two coils, with each coil featuring two wires. The wiring configuration is illustrated in the diagram below. If a different stepper motor is used, identify the wires belonging to the same coil by measuring the resistance between them using a multimeter. If two wires are part of the same coil, they will show a measurable resistance (typically a few ohms). If the wires are from different coils, the resistance will be very high (open circuit). To control the motor, three pins are required. PUL (Pulse): This pin is used to control the steps of the stepper motor. Each pulse sent to this pin will cause the motor to move one step. The frequency of the pulses determines the speed of the motor. DIR (Direction): This pin controls the direction of the motor rotation. A high signal (5V) will make the motor rotate in one direction, and a low signal (0V) will make it rotate in the opposite direction. ENA (Enable): This pin is used to enable or disable the motor. When this pin is high, the motor is disabled, and when it is low, the motor is enabled. PUL, DIR, and ENA are connected to the microcontroller\u2019s digital output pins. Additionally, the TB6600 stepper motor driver features six DIP (Dual In-line Package) switches on its board. These switches are used to configure two key parameters: Current: This sets the maximum current that the driver will supply to the motor. The configured current must not exceed the motor's rated current capacity. Microstep: Microstepping enables finer control of the stepper motor, resulting in smoother rotation and improved precision.\" The switches on the DIP switch bar are binary, with only two possible positions: on (1) and off (0). Refer to the diagram below for the switch numbering and their corresponding configurations. The stepper motor's current (amp) setting can be found in the model's specification sheet. For the MN3/BT stepper motor used in this project, a current setting of 2 amps is required, corresponding to the switch configuration S4, S5, S6 as ON, OFF, OFF. Reference : How to set dip switches correctly","title":"Integrated System Implementation"},{"location":"tour/integrated_system/#integrated-system-implementation","text":"","title":"Integrated System Implementation"},{"location":"tour/integrated_system/#apparatus-prototype","text":"A cage-based device is designed according to the marmoset experimental behavioral instrument (MXBI) [A.Calapai et al. 2022]. The device's design has been slightly modified from MXBI to enhance the capabilities of experiments. The main component is divided into three sections. Behavioral chamber Electronic compartment Waste bin","title":"Apparatus (Prototype)"},{"location":"tour/integrated_system/#equipments","text":"The electronics compartment on the \u200bleft side of the instrument contains: Raspberry Pi 4 Model B Raspberry Pi Camera Module 3 2x Visaton FR58, 8 \u03a9, 120\u201320,000 Hz: Note that one speaker is housed in the electronics compartment, while the other is wired to the opposite side of the instrument. Peristaltic pump (JIHPUMP MN3 Mini OEM Peristaltic Pumps MN3/BT) 134.2K WL-134 Long distance RFID Animal Tag Reader Module 24v 7Ah Lithium ion battery with XT60 connector HW-652 YAMAHA YDA138-E 12W+12W Dual Channel Digital Audio Amplifier Board DC 12V TB6600 Single Axis 4A Stepper Motor Driver Controller 9~42V Micro-Step CNC 3x 300W 20A DC-DC Adjustable Step Down Converter Module Constant Current The behavioral chamber in the middle hosts: Waveshare 10.1inch Resistive Touch Screen LCD","title":"Equipments"},{"location":"tour/integrated_system/#system-diagram","text":"The system utilizes a Raspberry Pi single-board computer to provide general-purpose input/output (GPIO) capabilities, enabling researchers to interface with a diverse range of external hardware components. The modular design allows for flexible hardware configurations tailored to specific task requirements.","title":"System Diagram"},{"location":"tour/integrated_system/#touch-screen-connection","text":"A 10-inch Waveshare HDMI LCD touchscreen is employed for visual cognition tasks. To facilitate resistive touch functionality, only five pins are necessary for communication via the Serial Peripheral Interface (SPI) protocol. SCK (Serial Clock): Clock signal from the master (Raspberry Pi) to synchronize data transmission. MOSI (Master Out Slave In): Used for sending data from the master (Raspberry Pi) to the touchscreen controller. MISO (Master In Slave Out): Used for receiving data from the touchscreen controller to the master. CE1 (Chip Enable 1/Chip Select 1): Used to select the touchscreen for communication (low active). IRQ (Interrupt Request): Used by the touchscreen to signal the master that an event has occurred (low level while the Touch Panel detects touching). To preserve the remaining GPIO pins and ensure a modular design, the Raspberry Pi is not mounted directly onto the display module, as recommended in Waveshare\u2019s documentation. Instead of soldering the five pins directly from the back of the panel to connect to the Raspberry Pi, a detachable interface is utilized. Refer to the diagram below for the connection details. The panel requires screen configuration and touch calibration before it can be operational. Refer to the 'Software Setting' and 'Touch Calibration' sections in the Waveshare documentation for detailed instructions. Waveshare 10.1inch HDMI LCD Documentation","title":"Touch Screen Connection"},{"location":"tour/integrated_system/#peristaltic-pumps-connection","text":"The Mini OEM Peristaltic Pump, model MN3/BT from JIHPump, is powered by a 24V DC, 48W stepper motor. To unlock its full potential, the system utilizes a TB6600 controller, enabling precise control and synchronization. The MN3/BT employs a 4-wire stepper motor, comprising two coils, with each coil featuring two wires. The wiring configuration is illustrated in the diagram below. If a different stepper motor is used, identify the wires belonging to the same coil by measuring the resistance between them using a multimeter. If two wires are part of the same coil, they will show a measurable resistance (typically a few ohms). If the wires are from different coils, the resistance will be very high (open circuit). To control the motor, three pins are required. PUL (Pulse): This pin is used to control the steps of the stepper motor. Each pulse sent to this pin will cause the motor to move one step. The frequency of the pulses determines the speed of the motor. DIR (Direction): This pin controls the direction of the motor rotation. A high signal (5V) will make the motor rotate in one direction, and a low signal (0V) will make it rotate in the opposite direction. ENA (Enable): This pin is used to enable or disable the motor. When this pin is high, the motor is disabled, and when it is low, the motor is enabled. PUL, DIR, and ENA are connected to the microcontroller\u2019s digital output pins. Additionally, the TB6600 stepper motor driver features six DIP (Dual In-line Package) switches on its board. These switches are used to configure two key parameters: Current: This sets the maximum current that the driver will supply to the motor. The configured current must not exceed the motor's rated current capacity. Microstep: Microstepping enables finer control of the stepper motor, resulting in smoother rotation and improved precision.\" The switches on the DIP switch bar are binary, with only two possible positions: on (1) and off (0). Refer to the diagram below for the switch numbering and their corresponding configurations. The stepper motor's current (amp) setting can be found in the model's specification sheet. For the MN3/BT stepper motor used in this project, a current setting of 2 amps is required, corresponding to the switch configuration S4, S5, S6 as ON, OFF, OFF. Reference : How to set dip switches correctly","title":"Peristaltic Pumps Connection"},{"location":"tour/webapp_explained/","text":"Web Application High Level Explained Delivering diverse tasks to analyze the phenotypic characteristics of non-human primates, as well as their complex nervous systems, necessitates distinct configurations of both hardware and software, each tailored to the specific requirements of the task. For this reason, combined with the flexibility of the GPIO on the Raspberry Pi system, which enables reconfigurable peripherals, we have designed the web application system with the idea of modularity to allow scalability of the experiments. The idea is to use the Django framework to gain access to functions such as authentication, information retrieval from a database, and cookie management. Overview The web application is devided into three sections. Server: Host the web application logic as well as the database server. User Clients: Researcher devices that access the web application's functions via a web browser. Device Clients: A cage-based device embedded with a Python script to automate the web browser for accessing the experimental application, manipulate the GPIO of the integrated system, and invoke API calls to the server backend to perform CRUD operations on the database. Server Database To centalize the system and allow mutiple intruments to work simutinueously. We have stored the state of the entire system in the database server. For instance, we reference each cage-based device in the RPIBOARDS table, storing its name, IP address, and other relevant information. We can define this using a Django model like this: class RPiBoards(models.Model): board_name = models.CharField(max_length=255, default=\"\") ip_address = models.GenericIPAddressField(protocol='IPv4') ssid = models.CharField(max_length=32 , blank=True , null=True) ssid_password = models.CharField(max_length=255, blank=True , null=True) def __str__(self)-> str: return self.board_name We also have the RPISTATES table for each device, which allows the instrument to track whether or not to run or end a task. This table also stores the state of the GPIO, enabling the edge device (the Raspberry Pi, in this case) to manipulate the peripherals. class RPiStates(models.Model): rpiboard = models.OneToOneField(RPiBoards, on_delete=models.CASCADE) is_occupied = models.BooleanField(default=False) game_instance_running = models.IntegerField(default=None, blank=True , null=True) start_game = models.BooleanField(default=False) stop_game = models.BooleanField(default=False) motor = models.BooleanField(default=False) def __str__(self)-> str: return self.rpiboard.board_name When it comes to the tasks, each device runs a different experiment instance (which may also involve different tasks). It is crucial to keep track of these states to manage the simultaneous operation of multiple instruments. An example of the GAMEINSTANCE table allows us to keep track of each task's information, such as which instrument is being used, which task is being performed, which primate is involved, the configuration profile, and other relevant details. class GameInstances(models.Model): name = models.CharField(max_length=255) game = models.ForeignKey(Games, on_delete=models.PROTECT) config = models.ForeignKey(GameConfig, on_delete=models.PROTECT, related_name=\"gameconfig\") rpiboard = models.ForeignKey(RPiBoards, on_delete=models.PROTECT , related_name=\"rpiboard\") primate = models.ForeignKey(Primates, on_delete=models.PROTECT , related_name=\"primate\") login_hist = models.DateTimeField() logout_hist = models.DateTimeField(blank=True , null=True) def __str__(self)-> str: return self.name Another crucial part is the experiment result of each task. This web application platform supports report generation, so we need to design the database carefully to ensure that the results of each task instance are stored properly. One way we can do this is by creating a REPORT table to separate each task's report. We would then create two additional tables based on the task: one table for the instance of the report and another table to store the actual result of the task. class Reports(models.Model): reportname = models.CharField(max_length=50) game = models.ForeignKey(Games, on_delete=models.PROTECT) def __str__(self)-> str: return self.reportname class FixationGameReport(models.Model): report = models.ForeignKey(Reports, on_delete=models.PROTECT) instance = models.OneToOneField(GameInstances, on_delete=models.PROTECT,related_name=\"fixationreportgameinstance\") gamereportname = models.CharField(max_length=50, blank=True , null=True) def __str__(self)-> str: return self.gamereportname class FixationGameResult(models.Model): fixationreport = models.ForeignKey(FixationGameReport, on_delete=models.PROTECT) timestamp = models.DateTimeField() feedback = models.BooleanField() feedbacktype = models.CharField(max_length=10) buttonsize = models.FloatField() def __str__(self)-> str: return self.fixationreport.gamereportname Web application The web application is powered by the Django framework. The reason for this is that having a clear separation between the different parts allows the system to scale for various tasks. By separating application servers, we can create the logic for multiple tasks without interfering with each other. Another benefit is that Django promotes the grouping of related functionality into reusable \"applications\" and, at a lower level, organizes related code into modules. The core components of this project are listed as follows: Web appplication logic API server User authentication/authorization application (via djoser and Django REST framework) Tasks application User Clients User clients are researchers and observers who can access the web application remotely to start or stop the experiment on each device, monitor the status of the experiment, or download reports. With the convenience of the Django template language, the web application's front end can update content dynamically from the database. The Django Template Language (DTL) is a built-in templating system in Django used to generate dynamic HTML content. It allows developers to embed Python-like expressions inside HTML files while maintaining separation between logic and presentation. Some of the core function of the Web application platform on user clients side: User authentication/authorization with tokenization, session management. Remotely controlled experiments on the edge device with customized configurations for each task. Dynamically update the state of each device in real-time, observe the experiment results, and end the session. Report generation: Support filtering by date, tasks, and optionally by instruments and primates. Device Clients Device clients, also known as cage-based devices in this project, are Raspberry Pi-based systems that also gain access to the web application, but as RPiClients users. The token from this user allows the server to grant permission for each device client to perform CRUD operations via APIs. The device clients are installed with Python scripts that leverage Selenium to automate the Chromium web browser. When the system is booted, it is automatically logged in with its own credentials, connects to the web application, and enters power-saving mode, waiting for instructions. The Python script keeps querying its own status at fixed intervals. When the user client makes an experiment request, the device switches to the corresponding task. Also, the GPIOs are manipulated according to status updates from the database, and when the task sends an update request for each GPIO, the system sends a PATCH operation to update its own state.","title":"WebApp Explained"},{"location":"tour/webapp_explained/#web-application-high-level-explained","text":"Delivering diverse tasks to analyze the phenotypic characteristics of non-human primates, as well as their complex nervous systems, necessitates distinct configurations of both hardware and software, each tailored to the specific requirements of the task. For this reason, combined with the flexibility of the GPIO on the Raspberry Pi system, which enables reconfigurable peripherals, we have designed the web application system with the idea of modularity to allow scalability of the experiments. The idea is to use the Django framework to gain access to functions such as authentication, information retrieval from a database, and cookie management.","title":"Web Application High Level Explained"},{"location":"tour/webapp_explained/#overview","text":"The web application is devided into three sections. Server: Host the web application logic as well as the database server. User Clients: Researcher devices that access the web application's functions via a web browser. Device Clients: A cage-based device embedded with a Python script to automate the web browser for accessing the experimental application, manipulate the GPIO of the integrated system, and invoke API calls to the server backend to perform CRUD operations on the database.","title":"Overview"},{"location":"tour/webapp_explained/#server","text":"","title":"Server"},{"location":"tour/webapp_explained/#database","text":"To centalize the system and allow mutiple intruments to work simutinueously. We have stored the state of the entire system in the database server. For instance, we reference each cage-based device in the RPIBOARDS table, storing its name, IP address, and other relevant information. We can define this using a Django model like this: class RPiBoards(models.Model): board_name = models.CharField(max_length=255, default=\"\") ip_address = models.GenericIPAddressField(protocol='IPv4') ssid = models.CharField(max_length=32 , blank=True , null=True) ssid_password = models.CharField(max_length=255, blank=True , null=True) def __str__(self)-> str: return self.board_name We also have the RPISTATES table for each device, which allows the instrument to track whether or not to run or end a task. This table also stores the state of the GPIO, enabling the edge device (the Raspberry Pi, in this case) to manipulate the peripherals. class RPiStates(models.Model): rpiboard = models.OneToOneField(RPiBoards, on_delete=models.CASCADE) is_occupied = models.BooleanField(default=False) game_instance_running = models.IntegerField(default=None, blank=True , null=True) start_game = models.BooleanField(default=False) stop_game = models.BooleanField(default=False) motor = models.BooleanField(default=False) def __str__(self)-> str: return self.rpiboard.board_name When it comes to the tasks, each device runs a different experiment instance (which may also involve different tasks). It is crucial to keep track of these states to manage the simultaneous operation of multiple instruments. An example of the GAMEINSTANCE table allows us to keep track of each task's information, such as which instrument is being used, which task is being performed, which primate is involved, the configuration profile, and other relevant details. class GameInstances(models.Model): name = models.CharField(max_length=255) game = models.ForeignKey(Games, on_delete=models.PROTECT) config = models.ForeignKey(GameConfig, on_delete=models.PROTECT, related_name=\"gameconfig\") rpiboard = models.ForeignKey(RPiBoards, on_delete=models.PROTECT , related_name=\"rpiboard\") primate = models.ForeignKey(Primates, on_delete=models.PROTECT , related_name=\"primate\") login_hist = models.DateTimeField() logout_hist = models.DateTimeField(blank=True , null=True) def __str__(self)-> str: return self.name Another crucial part is the experiment result of each task. This web application platform supports report generation, so we need to design the database carefully to ensure that the results of each task instance are stored properly. One way we can do this is by creating a REPORT table to separate each task's report. We would then create two additional tables based on the task: one table for the instance of the report and another table to store the actual result of the task. class Reports(models.Model): reportname = models.CharField(max_length=50) game = models.ForeignKey(Games, on_delete=models.PROTECT) def __str__(self)-> str: return self.reportname class FixationGameReport(models.Model): report = models.ForeignKey(Reports, on_delete=models.PROTECT) instance = models.OneToOneField(GameInstances, on_delete=models.PROTECT,related_name=\"fixationreportgameinstance\") gamereportname = models.CharField(max_length=50, blank=True , null=True) def __str__(self)-> str: return self.gamereportname class FixationGameResult(models.Model): fixationreport = models.ForeignKey(FixationGameReport, on_delete=models.PROTECT) timestamp = models.DateTimeField() feedback = models.BooleanField() feedbacktype = models.CharField(max_length=10) buttonsize = models.FloatField() def __str__(self)-> str: return self.fixationreport.gamereportname","title":"Database"},{"location":"tour/webapp_explained/#web-application","text":"The web application is powered by the Django framework. The reason for this is that having a clear separation between the different parts allows the system to scale for various tasks. By separating application servers, we can create the logic for multiple tasks without interfering with each other. Another benefit is that Django promotes the grouping of related functionality into reusable \"applications\" and, at a lower level, organizes related code into modules. The core components of this project are listed as follows: Web appplication logic API server User authentication/authorization application (via djoser and Django REST framework) Tasks application","title":"Web application"},{"location":"tour/webapp_explained/#user-clients","text":"User clients are researchers and observers who can access the web application remotely to start or stop the experiment on each device, monitor the status of the experiment, or download reports. With the convenience of the Django template language, the web application's front end can update content dynamically from the database. The Django Template Language (DTL) is a built-in templating system in Django used to generate dynamic HTML content. It allows developers to embed Python-like expressions inside HTML files while maintaining separation between logic and presentation. Some of the core function of the Web application platform on user clients side: User authentication/authorization with tokenization, session management. Remotely controlled experiments on the edge device with customized configurations for each task. Dynamically update the state of each device in real-time, observe the experiment results, and end the session. Report generation: Support filtering by date, tasks, and optionally by instruments and primates.","title":"User Clients"},{"location":"tour/webapp_explained/#device-clients","text":"Device clients, also known as cage-based devices in this project, are Raspberry Pi-based systems that also gain access to the web application, but as RPiClients users. The token from this user allows the server to grant permission for each device client to perform CRUD operations via APIs. The device clients are installed with Python scripts that leverage Selenium to automate the Chromium web browser. When the system is booted, it is automatically logged in with its own credentials, connects to the web application, and enters power-saving mode, waiting for instructions. The Python script keeps querying its own status at fixed intervals. When the user client makes an experiment request, the device switches to the corresponding task. Also, the GPIOs are manipulated according to status updates from the database, and when the task sends an update request for each GPIO, the system sends a PATCH operation to update its own state.","title":"Device Clients"},{"location":"tutorials/adding_tasks/","text":"Adding Tasks When it comes to adding tasks, this platform aims to reduce the workload of researchers as much as possible. There is still a need for some backend Django implementation, but most of it will be provided with template code, which you'll need to modify slightly to make it work. So, simply speaking, the step that needs to be done is Get the project codebase on your local PC (fork the repository). Set up the enviroment for development. Create a feature branch to experiment with your ideas. Add new applications (tasks) to the web application. Implement the logic for the core function of the task in the Django view. Map the URL pattern. Implement the task logic. (To be update........) Requirement Git Pipenv Step 1: Get The Project Codebase. The first step is to get the project codebase on your local machine. There are two scenarios, depending on whether or not you have access to the repository. As an external contributor, you're contributing to an open-source project, so you don't have write access,follow these steps: Scenario 1: You Have Access to the Repository (Team Member) If you are member of the organization, follow these steps. Step 1: Clone the Repository First, clone the repository to your local machine: git clone <repository_url> Then, navigate into the project directory: cd PrimatesBehaviorWebApp Scenario 2: You Don't Have Push Access (External Contributor) Step 1: Fork the Repository Go to the project repository page . Click the \"Fork\" button in the upper right corner of the screen. (this creates a copy of the repository under your account). Step 2: Clone Your Fork Copy the forked repository to your local machine: git clone https://github.com/rsongphon/PrimatesBehaviorWebApp.git Move into the project directory: cd PrimatesBehaviorWebApp Step 3.1: Add the Original Repository as an Upstream To keep your fork updated with the original repository: git remote add upstream https://github.com/rsongphon/PrimatesBehaviorWebApp.git Step 2: Create a New Branch Before making changes, create a new branch for your work: git checkout -b my-feature-branch Step 2: Set up the enviroment for development. (\u0e15\u0e23\u0e07\u0e19\u0e35\u0e49\u0e15\u0e49\u0e2d\u0e07\u0e40\u0e17\u0e2a\u0e40\u0e22\u0e2d\u0e30\u0e46\u0e46\u0e46\u0e46\u0e46\u0e46\u0e46\u0e46\u0e46) This project reqired some packages and mock-up database in your local machine in order to make the whole web app running so you can experiment with your feature. After you have pipenv in you system, install all dependencies for this project. pipenv sync After that, activate the environment. pipenv shell Create and imported MySQL database on the target machine In the project directory, there is a file called database_backup.sql. This file will be used to create a mock-up database with the correct schema, ensuring that the web application runs properly. First, install Mysql server with mysqlclient package, depending on machine. Refer to this documentation in the \"Install\" section for details on each operating system. The MySQL server should run automatically after installation. If it doesn't, start the service manually, depending on your system. Windows Open Command Prompt as Administrator. Run the following command: net start mssqlserver Linux (Ubuntu, CentOS, etc.): Open a terminal and run the following command: sudo systemctl start mssql-server macOS (Homebrew): brew services start mysql Log in to the MySQL server on the target machine as root user: This process requires administrative permissions, so you will need to grant them depending on your system (such as sudo for linux/mac). macOS/Linux: sudo mysql -u root -p Password for root leaves as blank \u0e15\u0e23\u0e07\u0e19\u0e35\u0e49\u0e04\u0e49\u0e2d\u0e07\u0e2a\u0e23\u0e49\u0e32\u0e07 user admingame \u0e14\u0e49\u0e27\u0e22 <<--- \u0e40\u0e1e\u0e34\u0e48\u0e21 document Create a new database CREATE DATABASE PrimatesGameDB; Import the database backup on the target machine. Once the database is created, import the SQL data dump into the new database: sudo mysql -u root -p PrimatesGameDB < database_backup.sql This will restore the database on the target machine. After the database is imported, you can run Django migrations to ensure the schema is up to date: python3 manage.py migrate Now, it's a good time to check the web application to see if it's running correctly, run the command. python3 manage.py runserver 0.0.0.0:8000 This will run the web application on your local system. Go to Site administration page by url http://127.0.0.1:8000/admin/ Login as admin (username and password are in user.txt in root directory of the project file) Check if database has all table present. Step 3: Create a feature branch. Creating a feature branch allows you to experiment with your code and create tasks as you like. Once you've finished testing, you can merge your code back into the original main branch. For more information about git branch check git checkout -b name-of-your-branch Step 3: Add new applications (tasks) to the web application. Now the important step, adding new application (task) to web app. python3 manage.py startapp PrimalGame_Your-Task-Name Replace 'Your-Task-Name' with your preferred name. You will see new directory with your app name in the root directory of the project. In this directory, you will see some scipts that need for your app. No need to do anything for these script now. Now, add your new application in the project. All of the requirement app use in this project need to include in setting.py file in project level. Go to setting.py located in project directory, in this case, under PrimatesGame Locate INSTALLED_APPS section and add new app at the last line (in square bracket) in the format like this. 'PrimalGame_Your-Task-Name', Example of INSTALLED_APPS section after adding new application INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'PrimalGameAPI', 'rest_framework', 'djoser', 'PrimalGame_Your-Task-Name' ] Step 4 : Implement the logic for the core function. Now we will implement some core function to make your application work. First, your application need the HTML page as","title":"Adding Tasks"},{"location":"tutorials/adding_tasks/#adding-tasks","text":"When it comes to adding tasks, this platform aims to reduce the workload of researchers as much as possible. There is still a need for some backend Django implementation, but most of it will be provided with template code, which you'll need to modify slightly to make it work. So, simply speaking, the step that needs to be done is Get the project codebase on your local PC (fork the repository). Set up the enviroment for development. Create a feature branch to experiment with your ideas. Add new applications (tasks) to the web application. Implement the logic for the core function of the task in the Django view. Map the URL pattern. Implement the task logic. (To be update........)","title":"Adding Tasks"},{"location":"tutorials/adding_tasks/#requirement","text":"Git Pipenv","title":"Requirement"},{"location":"tutorials/adding_tasks/#step-1-get-the-project-codebase","text":"The first step is to get the project codebase on your local machine. There are two scenarios, depending on whether or not you have access to the repository. As an external contributor, you're contributing to an open-source project, so you don't have write access,follow these steps:","title":"Step 1: Get The Project Codebase."},{"location":"tutorials/adding_tasks/#scenario-1-you-have-access-to-the-repository-team-member","text":"If you are member of the organization, follow these steps.","title":"Scenario 1: You Have Access to the Repository (Team Member)"},{"location":"tutorials/adding_tasks/#step-1-clone-the-repository","text":"First, clone the repository to your local machine: git clone <repository_url> Then, navigate into the project directory: cd PrimatesBehaviorWebApp","title":"Step 1: Clone the Repository"},{"location":"tutorials/adding_tasks/#scenario-2-you-dont-have-push-access-external-contributor","text":"","title":"Scenario 2: You Don't Have Push Access (External Contributor)"},{"location":"tutorials/adding_tasks/#step-1-fork-the-repository","text":"Go to the project repository page . Click the \"Fork\" button in the upper right corner of the screen. (this creates a copy of the repository under your account).","title":"Step 1: Fork the Repository"},{"location":"tutorials/adding_tasks/#step-2-clone-your-fork","text":"Copy the forked repository to your local machine: git clone https://github.com/rsongphon/PrimatesBehaviorWebApp.git Move into the project directory: cd PrimatesBehaviorWebApp","title":"Step 2: Clone Your Fork"},{"location":"tutorials/adding_tasks/#step-31-add-the-original-repository-as-an-upstream","text":"To keep your fork updated with the original repository: git remote add upstream https://github.com/rsongphon/PrimatesBehaviorWebApp.git","title":"Step 3.1: Add the Original Repository as an Upstream"},{"location":"tutorials/adding_tasks/#step-2-create-a-new-branch","text":"Before making changes, create a new branch for your work: git checkout -b my-feature-branch","title":"Step 2: Create a New Branch"},{"location":"tutorials/adding_tasks/#step-2-set-up-the-enviroment-for-development","text":"","title":"Step 2: Set up the enviroment for development."},{"location":"tutorials/adding_tasks/#_1","text":"This project reqired some packages and mock-up database in your local machine in order to make the whole web app running so you can experiment with your feature. After you have pipenv in you system, install all dependencies for this project. pipenv sync After that, activate the environment. pipenv shell Create and imported MySQL database on the target machine In the project directory, there is a file called database_backup.sql. This file will be used to create a mock-up database with the correct schema, ensuring that the web application runs properly. First, install Mysql server with mysqlclient package, depending on machine. Refer to this documentation in the \"Install\" section for details on each operating system. The MySQL server should run automatically after installation. If it doesn't, start the service manually, depending on your system.","title":"(\u0e15\u0e23\u0e07\u0e19\u0e35\u0e49\u0e15\u0e49\u0e2d\u0e07\u0e40\u0e17\u0e2a\u0e40\u0e22\u0e2d\u0e30\u0e46\u0e46\u0e46\u0e46\u0e46\u0e46\u0e46\u0e46\u0e46)"},{"location":"tutorials/adding_tasks/#windows","text":"Open Command Prompt as Administrator. Run the following command: net start mssqlserver","title":"Windows"},{"location":"tutorials/adding_tasks/#linux-ubuntu-centos-etc","text":"Open a terminal and run the following command: sudo systemctl start mssql-server","title":"Linux (Ubuntu, CentOS, etc.):"},{"location":"tutorials/adding_tasks/#macos-homebrew","text":"brew services start mysql Log in to the MySQL server on the target machine as root user: This process requires administrative permissions, so you will need to grant them depending on your system (such as sudo for linux/mac).","title":"macOS (Homebrew):"},{"location":"tutorials/adding_tasks/#macoslinux","text":"sudo mysql -u root -p Password for root leaves as blank","title":"macOS/Linux:"},{"location":"tutorials/adding_tasks/#user-admingame-document","text":"Create a new database CREATE DATABASE PrimatesGameDB; Import the database backup on the target machine. Once the database is created, import the SQL data dump into the new database: sudo mysql -u root -p PrimatesGameDB < database_backup.sql This will restore the database on the target machine. After the database is imported, you can run Django migrations to ensure the schema is up to date: python3 manage.py migrate Now, it's a good time to check the web application to see if it's running correctly, run the command. python3 manage.py runserver 0.0.0.0:8000 This will run the web application on your local system. Go to Site administration page by url http://127.0.0.1:8000/admin/ Login as admin (username and password are in user.txt in root directory of the project file) Check if database has all table present.","title":"\u0e15\u0e23\u0e07\u0e19\u0e35\u0e49\u0e04\u0e49\u0e2d\u0e07\u0e2a\u0e23\u0e49\u0e32\u0e07 user admingame \u0e14\u0e49\u0e27\u0e22 &lt;&lt;--- \u0e40\u0e1e\u0e34\u0e48\u0e21 document"},{"location":"tutorials/adding_tasks/#step-3-create-a-feature-branch","text":"Creating a feature branch allows you to experiment with your code and create tasks as you like. Once you've finished testing, you can merge your code back into the original main branch. For more information about git branch check git checkout -b name-of-your-branch","title":"Step 3: Create a feature branch."},{"location":"tutorials/adding_tasks/#step-3-add-new-applications-tasks-to-the-web-application","text":"Now the important step, adding new application (task) to web app. python3 manage.py startapp PrimalGame_Your-Task-Name Replace 'Your-Task-Name' with your preferred name. You will see new directory with your app name in the root directory of the project. In this directory, you will see some scipts that need for your app. No need to do anything for these script now. Now, add your new application in the project. All of the requirement app use in this project need to include in setting.py file in project level. Go to setting.py located in project directory, in this case, under PrimatesGame Locate INSTALLED_APPS section and add new app at the last line (in square bracket) in the format like this. 'PrimalGame_Your-Task-Name', Example of INSTALLED_APPS section after adding new application INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'PrimalGameAPI', 'rest_framework', 'djoser', 'PrimalGame_Your-Task-Name' ]","title":"Step 3: Add new applications (tasks) to the web application."},{"location":"tutorials/adding_tasks/#step-4-implement-the-logic-for-the-core-function","text":"Now we will implement some core function to make your application work. First, your application need the HTML page as","title":"Step 4 : Implement the logic for the core function."}]}